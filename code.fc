
() send_message_back(addr, ans_tag, query_id, body, extra, grams, mode) impure {
  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_grams(grams)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(ans_tag, 32)
    .store_uint(query_id, 64);
  if (body >= 0) {
    msg~store_uint(body, 32);
  }
  if (extra >= 0) {
    msg~store_uint(extra, 32);
  }
  send_raw_message(msg.end_cell(), mode);
}

(int, int, int, int) check_blind_bids(auction_type, bidding_fee, bids, reserved_balance, force_completion) {
  var winner_addr = 0;
  var winner_bid = 0;
  var winner_received = 0;
  var all_decrypted = true;
  var bidder_addr = -1;
  do {
    (bidder_addr, var bid, var f) = bids.udict_get_next?(256, bidder_addr);
    if (f) {
      var received_amount = bid~load_grams();
      var bid_signature = bid~load_bits(512);
      ifnot (bid.slice_data_empty?) {
        var actual_amount = bid~load_grams();
        if (actual_amount > winner_bid) {
          ;; TODO: handle case when there's two equal top bids (the first one wins?)
          winner_addr = bidder_addr;
          winner_bid = actual_amount;
          winner_received = received_amount;
        }
      } else {
        all_decrypted = false;
      }
    }
  } until (~ f);

  if ((winner_bid == 0) | (!force_completion & !all_decrypted)) {
    return (winner_addr, winner_bid, all_decrypted, reserved_balance)
  }

  bidder_addr = -1;
  var second_bid = 0;
  do {
    (bidder_addr, var bid, var f) = bids.udict_get_next?(256, bidder_addr);
    if (f) {
      var received_amount = bid~load_grams();
      ifnot (bidder_addr == winner_addr) {
        reserved_balance = reserved_balance - (received_amount - bidding_fee);

        send_raw_message(begin_cell()
          .store_uint(0x18, 6)
          .store_slice(bidder_addr)
          .store_grams(received_amount - bidding_fee)
          .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
          .store_uint(0, 32) ;; Simple money transfer
        .end_cell(), 0);

        var bid_signature = bid~load_bits(512);
        ifnot (bid.slice_data_empty?) {
          var actual_amount = bid~load_grams();
          if (actual_amount > second_bid && actual_amount < winner_bid) {
            second_bid = actual_amount;
          }
        }
      }
    }
  } until (~ f);

  if (auction_type == 65) {
    ;; Vickrey auction: winner pays second price instead of his own
    winner_bid = second_bid;
  }

  if (winner_received > winner_bid) {
    reserved_balance = reserved_balance - (winner_received - bidding_fee);

    send_raw_message(begin_cell()
      .store_uint(0x18, 6)
      .store_slice(winner_addr)
      .store_grams(winner_received - winner_bid)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(0, 32) ;; Simple money transfer
    .end_cell(), 0);
  }

  return (winner_addr, winner_bid, all_decrypted, reserved_balance)
}

() send_auction_notification(int notification_addr, int auction_id, int winner_addr, int winner_bid, cell auction) impure {
  send_raw_message(begin_cell()
    .store_uint(0xc4ff, 17)       ;; 0 11000100 0xff 
    .store_uint(notification_addr, 256)
    .store_grams(1 << 30)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(0x27fca6b9, 32)   ;; Notification query
    .store_uint(auction_id, 64)
    .store_uint(winner_addr, 256) ;; Bidder addr (can be 0 if there was no bids!)
    .store_grams(winner_bid)      ;; Winning bid amount
    .store_ref(auction)           ;; Detailed info about auction (before this bid)
  .end_cell(), 1);
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
  var cs = in_msg;
  var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  if (flags & 1) { ;; ignore bounced
    return ();
  }
  var src_addr = cs~load_msg_addr();
  if (in_msg.slice_empty?()) {
    return
  }
  var op = cs~load_uint(32);
  if (op == 0) {
    return
  }
  var ds = get_data().begin_parse();
  var stored_seqno = ds~load_uint(32);
  var notification_addr = ds~load_uint(256);
  var auctions = ds~load_dict();
  int query_id = cs~load_uint(64);
  if (op == 100) {
    ;; Place a bid
    var auction_id = cs~load_uint(32);
    var (auction, auction_found) = auctions.udict_get?(32, auction_id);
    ifnot (auction_found) {
      return send_message_back(src_addr, 0xfffffffe, query_id, op, 1, 0, 64);
    }

    var auction_type = auction~load_uint(8);
    var start_time = auction~load_uint(32);
    ifnot (start_time < now()) { ;; => auction is not yet started
      return send_message_back(src_addr, 0xfffffffe, query_id, op, 2, 0, 64);
    }

    var end_time = auction~load_uint(32);
    ifnot (end_time > now()) { ;; => auction is already finished
      return send_message_back(src_addr, 0xfffffffe, query_id, op, 3, 0, 64);
    }

    var bidding_fee = auction~load_grams();
    ifnot (msg_value >= bidding_fee) { ;; => attached value is not enough even for a fee
      return send_message_back(src_addr, 0xfffffffe, query_id, op, 4, 0, 64);
    }

    var buyout_price = auction~load_grams();
    
    var is_won = false;
    if (auction_type < 64) {
      ;; English auction

      if ((buyout_price > 0) & (msg_value >= buyout_price)) {
        ;; Enough money to instantly complete this auction
        is_won = true;
      }

      var initial_price = auction~load_grams();
      ifnot (msg_value >= initial_price) { ;; => attached value is not enough even for initial price
        return send_message_back(src_addr, 0xfffffffe, query_id, op, 5, 0, 64);
      }

      var minimum_step = auction~load_grams();
      var current_price = auction~load_grams();
      ifnot (current_price == 0) {
        ifnot (msg_value >= current_price + minimum_step) { ;; => attached value is not enough to outbid current top bidder
          return send_message_back(src_addr, 0xfffffffe, query_id, op, 6, 0, 64);
        }

        reserved_balance = reserved_balance - (current_price - bidding_fee);

        ;; Replace current bidder, return him his bid
        var current_addr = auction~load_uint(256);
        send_raw_message(begin_cell()
          .store_uint(0x18, 6)
          .store_slice(current_addr)
          .store_grams(current_price - bidding_fee)
          .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
          .store_uint(0, 32) ;; Simple money transfer
        .end_cell(), 0);
      }

      if (!is_won) {
        reserved_balance = reserved_balance + (msg_value - bidding_fee);

        auctions~udict_set_builder(32, auction_id, begin_cell()
          .store_uint(auction_type, 8)
          .store_uint(start_time, 32)
          .store_uint(end_time, 32)
          .store_grams(bidding_fee)
          .store_grams(buyout_price)
          .store_grams(initial_price)
          .store_grams(msg_value)
          .store_uint(src_addr, 256));
      }
    } else {
      ;; Blind auction
      var decrypt_time = auction~load_uint(32);
      var fixed_amount = auction~load_grams();
      ifnot (msg_value >= fixed_amount) { ;; => all bids should be equal to the fixed price (the remainders will be returned later)
        return send_message_back(src_addr, 0xfffffffe, query_id, op, 7, 0, 64);
      }
      if ((buyout_price > fixed_amount) && (msg_value >= buyout_price)) {
        is_won = true;
      } else {
        var bids = auction~load_dict();
        ;; Add to bidders
        var (bid, bid_found) = bids.udict_get?(256, src_addr);
        if (bid_found) { ;; => already participated in this auction (not allowed in blind auctions)
          return send_message_back(src_addr, 0xfffffffe, query_id, op, 8, 0, 64);
        }

        reserved_balance = reserved_balance + (msg_value - bidding_fee)

        var bid_signature = cs~load_bits(512);

        ;; Store encrypted bid for later
        bids~udict_set_builder(256, src_addr, begin_cell()
          .store_grams(msg_value)
          .store_bits(bid_signature));

        auctions~udict_set_builder(32, auction_id, begin_cell()
          .store_uint(auction_type, 8)
          .store_uint(start_time, 32)
          .store_uint(end_time, 32)
          .store_grams(bidding_fee)
          .store_grams(buyout_price)
          .store_uint(decrypt_time, 32)
          .store_grams(fixed_amount)
          .store_dict(bids));
      }
    }

    if (is_won) {
      ;; Remove auction from state, send notification
      auctions~udict_delete_get?(32, auction_id);

      send_raw_message(begin_cell()
        .store_uint(0xc4ff, 17)     ;; 0 11000100 0xff 
        .store_uint(notification_addr, 256)
        .store_grams(1 << 30)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x27fca6b9, 32) ;; Notification query
        .store_uint(auction_id, 64)
        .store_uint(src_addr, 256)  ;; Bidder addr
        .store_grams(msg_value)     ;; Winning bid amount
        .store_ref(auction)         ;; Detailed info about auction (before this bid)
      .end_cell(), 1);
    }

    set_data(
      begin_cell()
        .store_uint(stored_seqno, 32)
        .store_uint(owner_pubkey, 256)
        .store_uint(notification_addr, 256)
        .store_grams(reserved_balance)
        .store_dict(auctions)
      .end_cell()
    );
    return
  } elseif (op == 101) {
    ;; Ping an auction (trigger winner selection if now() >= end_time or, for blind auctions, now() >= decrypt_time)
    var auction_id = cs~load_uint(32);
    var (auction, auction_found) = auctions.udict_get?(32, auction_id);
    ifnot (auction_found) {
      return send_message_back(src_addr, 0xfffffffe, query_id, op, 1, 0, 64);
    }

    var auction_type = auction~load_uint(8);
    var start_time = auction~load_uint(32);
    var end_time = auction~load_uint(32);
    if (end_time > now()) { ;; => auction is not yet finished
      return send_message_back(src_addr, 0xfffffffe, query_id, op, 3, 0, 64);
    }

    var bidding_fee = auction~load_grams();
    var buyout_price = auction~load_grams();
    var winner_addr = 0;
    var winner_bid = 0;
    if (auction_type < 64) {
      ;; English auction
      var initial_price = auction~load_grams();
      var minimum_step = auction~load_grams();
      winner_bid = auction~load_grams();
      ifnot (winner_bid == 0) {
        winner_addr = auction~load_uint(256);
        reserved_balance = reserved_balance - (current_price - bidding_fee);
      }
    } else {
      ;; Blind auction
      var decrypt_time = auction~load_uint(32);
      if (decrypt_time > now()) { ;; => auction's decryption stage is not yet finished
        return send_message_back(src_addr, 0xfffffffe, query_id, op, 3, 0, 64);
      }

      var fixed_amount = auction~load_grams();
      var bids = auction~load_dict();
      (winner_addr, winner_bid, var all_decrypted, reserved_balance) = check_blind_bids(auction_type, bidding_fee, bids, reserved_balance, true);
    }

    ;; Remove auction from state, send notification
    auctions~udict_delete_get?(32, auction_id);
    send_auction_notification(notification_addr, auction_id, winner_addr, winner_bid, auction);

    set_data(
      begin_cell()
        .store_uint(stored_seqno, 32)
        .store_uint(owner_pubkey, 256)
        .store_uint(notification_addr, 256)
        .store_grams(reserved_balance)
        .store_dict(auctions)
      .end_cell()
    );
    
    ;; Return unused money
    return send_message_back(src_addr, 0, query_id, op, 0, 0, 64);
  }

  ifnot (op & (1 << 31)) {
    ;; unknown query, return error
    return send_message_back(src_addr, 0xffffffff, query_id, op, 0, 0, 64);
  }
}

() recv_external(slice in_msg) impure {
  var signature = in_msg~load_bits(512);
  var cs = in_msg;
  var (msg_seqno, valid_until, op) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
  throw_if(35, valid_until < now());

  var ds = get_data().begin_parse();
  var stored_seqno = ds~load_uint(32);
  throw_unless(33, msg_seqno == stored_seqno);

  var owner_pubkey = ds~load_uint(256);
  var notification_addr = ds~load_uint(256);
  var reserved_balance = ds~load_grams();
  var auctions = ds~load_dict();

  if (op == 102) {
    ;; Decrypt an encrypted bid (in a blind auction)
    var current_pubkey = cs~load_uint(256);
    throw_unless(34, check_signature(slice_hash(in_msg), signature, current_pubkey));
    var auction_id = cs~load_uint(32);
    var (auction, auction_found) = auctions.udict_get?(32, auction_id);
    throw_unless(35, auction_found);

    var auction_type = auction~load_uint(8);
    throw_unless(36, auction_type >= 64); ;; decrypt needed only for blind auctions

    var start_time = auction~load_uint(32);
    var end_time = auction~load_uint(32);
    throw_unless(37, end_time > now()); ;; => auction is not yet finished
    var bidding_fee = auction~load_grams();
    var buyout_price = auction~load_grams();
    var decrypt_time = auction~load_uint(32);
    throw_unless(38, decrypt_time < now()); ;; => auction's decryption stage is already finished
    var fixed_amount = auction~load_grams();
    var bids = auction~load_dict();

    var current_addr = cs~load_uint(256);
    var (bid, bid_found) = bid.udict_get?(256, current_addr);
    throw_unless(39, bid_found);

    var received_amount = bid~load_grams();
    var bid_signature = bid~load_bits(512);

    var subcell = cs~load_ref();
    throw_unless(40, check_signature(slice_hash(subcell), bid_signature, current_pubkey));
    throw_unless(41, subcell~load_uint(32) == auction_id);
    throw_unless(42, subcell~load_uint(256) == current_addr);

    accept_message();

    var actual_amount = subcell~load_grams();
    if (actual_amount >= initial_price && actual_amount <= received_amount) {
      bids~udict_set_builder(256, current_addr, begin_cell()
        .store_grams(received_amount)
        .store_bits(bid_signature)
        .store_grams(actual_amount));
    }

    var (winner_addr, winner_bid, all_decrypted, reserved_balance) = check_blind_bids(auction_type, bidding_fee, bids, reserved_balance, false);

    if (all_decrypted) {
      ;; Remove auction from state, send notification
      auctions~udict_delete_get?(32, auction_id);
      send_auction_notification(notification_addr, auction_id, winner_addr, winner_bid, auction);
    }
  } else {
    throw_unless(36, check_signature(slice_hash(in_msg), signature, owner_pubkey));
    accept_message();
  }

  if (op == 1) {
    var transfer_balance = 0;

    ;; Withdraw money (just like from a regular wallet)
    cs~touch();
    while (!cs.slice_empty?()) {
      var addr = cs~load_uint(256);
      var amount = cs~load_grams();

      transfer_balance += amount;
      var remaining_balance = get_balance() - transfer_balance;
      throw_unless(44, reserved_balance >= remaining_balance);

      send_raw_message(begin_cell()
        .store_uint(0x18, 6)
        .store_slice(addr)
        .store_grams(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0, 32) ;; Simple money transfer
      .end_cell(), 0);
    }
  } elseif (op == 2) {
    ;; Create new auction

  } elseif (op == 3) {
    ;; Cancel an auction

  }

  set_data(
    begin_cell()
      .store_uint(stored_seqno + 1, 32)
      .store_uint(owner_pubkey, 256)
      .store_uint(notification_addr, 256)
      .store_grams(reserved_balance)
      .store_dict(auctions)
    .end_cell()
  );
}

;; Returns current sequence number

int seqno() method_id {
  return get_data().begin_parse().preload_uint(32);
}